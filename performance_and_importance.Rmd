---
title: "measure performance and feature importances with DALEX + mlr"
author: "Satoshi Kato"
date: "`r format(Sys.time(), '%Y/%m/%d')`"
output:
  html_document:
    fig_caption: yes
    pandoc_args:
    - --from
    - markdown+autolink_bare_uris+tex_math_single_backslash-implicit_figures
    toc: yes
    toc_depth: 4
  word_document:
    toc: yes
    toc_depth: 3
  pdf_document:
    toc: yes
    toc_depth: 3
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
require(tidyverse)
require(mlr)
require(iml)

knitr::opts_knit$set(progress = TRUE, 
                     verbose = TRUE, 
                     root.dir = ".")

knitr::opts_chunk$set(collapse = TRUE, 
                      comment = "", 
                      message = TRUE, 
                      warning = FALSE, 
                      echo=TRUE)
set.seed(12345)
```

# read mlr models

regression task for Boston dataset.

```{r data.prep}
data("Boston", package  = "MASS")
Boston.task <- makeRegrTask(data = Boston, target = "medv")

model.regr.RF <- makeLearner("regr.randomForest") %>% 
  train(Boston.task)

# tuned.model <- readRDS("./tuned_models.RDS")
# model.names <- names(tuned.model)
# tuned.model %>% str(2)
```

# DALEX + mlr

according to:

https://rawgit.com/pbiecek/DALEX_docs/master/vignettes/DALEX_mlr.html

# The explain() function

## prepare customized predit()

For the models created by mlr package we have to provide custom predict function which takes two arguments: model and newdata and returns a numeric vector with predictions because function predict() from mlr returns not only predictions but an object with more information.

```{r}
predictMLR <- function(object, newdata) {
  pred <- predict(object, newdata=newdata)
  response <- pred$data$response
  return(response)
}

```

## build explainer

```{r}
library("DALEX")

explainer <-  DALEX::explain(model = model.regr.RF,
                             data  = Boston, 
                             y     = Boston$medv,
                             predict_function = predictMLR)
```

# measure model performance

Empirical Cumulative Distribution Function (ecdf) of residual error is as default.

```{r}
mp <- model_performance(explainer)
str(mp)
plot(mp)
plot(mp, geom = "boxplot")
```

# Variable importance

## simple

`type="raw"` is as default.

```{r}
var.imp <- variable_importance(explainer     = explainer, 
                               loss_function = loss_root_mean_square)
plot(var.imp)
print(var.imp)

```

## set baseline from fullmodel

For better comparison of the models we can hook the variabe importance at 0 using the type="difference", returns `drop_loss - drop_loss_full_model`.
```{r}
var.imp.diff <- variable_importance(explainer     = explainer,
                                    loss_function = loss_root_mean_square,
                                    type          = "difference")

plot(var.imp.diff)
```
## model comparison

TBD
